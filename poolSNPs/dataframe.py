import pysam
import pandas as pd
import numpy as np
from scipy.stats import *

from VCFPooling.poolSNPs import chunkvcf as chkvcf
from VCFPooling.persotools.files import *

"""
Building pandas Dataframes from VCF-files for plotting
"""


class PandasMixedVCF(object):
    #TODO: implement aaf property
    """
    Pandas objects and methods for manipulating VCF files. Any format.
    Implements pysam methods into Pandas structures.
    Drawback: extremely slow...
    """
    def __init__(self, vcfpath: FilePath, format: str = None, indextype: str = 'id'):
        """
        :param vcfpath:
        :param indextype: identifier for variants: 'id', 'chrom:pos'.
        Must be 'chrom:pos' if the input has been generated by Phaser
        """
        self.path = vcfpath
        self.fmt = format
        self.idx = indextype
        obj = pysam.VariantFile(self.path)
        self.samples = list(obj.header.samples)

    def load(self):
        # object returned can be read only once
        return pysam.VariantFile(self.path)

    @property
    def variants(self) -> pd.Index:
        """
        Read variants identifiers ordered as in the input file
        :return:
        """
        vcfobj = self.load()
        vars = []
        if self.idx == 'id':
            for var in vcfobj:
                vars.append(var.id)
        if self.idx == 'chrom:pos':
            for var in vcfobj:
                vars.append(':'.join([str(var.chrom), str(var.pos)]))

        return pd.Index(data=vars, dtype=str, name='variants')

    @property
    def phases(self) -> pd.DataFrame:
        # TODO: if fmt GT
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars), len(self.samples)), dtype=float)
        for i, var in enumerate(vcfobj):
            pass
            # arr[i, :] = var.gt_phases

        return pd.DataFrame(arr, index=vars, columns=self.samples, dtype=bool)

    def vcf2dframe(self) -> tuple:
        # TODO: deprecate
        """
       Throws the genotypes values of a VCF file into side-DataFrames.
       :return: two data frames, one for each allele of the genotype
       """
        vcfobj = self.load()
        vars = self.variants
        arr = np.empty((len(vars), len(self.samples), 2), dtype=int)
        for i, var in enumerate(vcfobj):
            arr[i, :, :] = np.array(g[self.fmt] for g in var.samples.values()).astype(float)
        # alleles 1
        df0 = pd.DataFrame(arr[:, :, 0], index=vars.rename('id'), columns=self.samples)
        # alleles 2
        df1 = pd.DataFrame(arr[:, :, 1], index=vars.rename('id'), columns=self.samples)

        return df0, df1

    def genotypes(self) -> pd.DataFrame:
        """
       Throws the formatted genotypes values of a VCF file into a DataFrame.
       :return: DataFrame
       """
        lines = chkvcf.PysamVariantCallGenerator(self.path, format=self.fmt)
        df = pd.DataFrame(lines, index=self.variants.rename('id'), columns=self.samples)

        return df

    def trinary_encoding(self) -> pd.DataFrame:
        # TODO: fmt GT only!
        vcfobj = self.load()
        vars = self.variants
        arr = np.empty((len(vars), len(self.samples)), dtype=float)
        missing = np.vectorize(lambda x: np.nan if x is None else x)
        for i, var in enumerate(vcfobj):
            # missing are read as None
            gts = np.array([g[self.fmt] for g in var.samples.values()]).astype(float)
            tri = missing(gts).sum(axis=-1)
            arr[i, :] = np.nan_to_num(tri, nan=-1)
        dftrinary = pd.DataFrame(arr, index=vars, columns=self.samples, dtype=int)

        return dftrinary
