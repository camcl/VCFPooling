from cyvcf2 import VCF
import pysam
import pandas as pd
from scipy.stats import *

from scripts.VCFPooling.poolSNPs import chunkvcf as chkvcf
from persotools.files import *

"""
Building pandas Dataframes from VCF-files for plotting
"""


class PandasVCF(object):
    # TODO: deprecate for PandasMixedVCF
    """
    Pandas objects and methods for manipulating VCF files. /!\ GT format only!
    Implements cyvcf2 methods into Pandas structures.
    * trinary encoding
    * AF_INFO extraction, with variant index
    * AAF extraction, with variant index
    * write to csv file

    Example: Get a DataFrame with AF_INFO, AAF and heterozygosity rate for each variant
    pdvcf = PandasVCF(<path>)
    df = pd.concat([pdvcf.af_info, pdvcf.aaf, pdvcf.het_rate], axis=1)
    """
    def __init__(self, vcfpath: FilePath, indextype: str = 'id'):
        """
        :param vcfpath:
        :param indextype: identifier for variants: 'id', 'chrom:pos'.
        Must be 'chrom:pos' if the input has been generated by Phaser
        """
        self.path = vcfpath
        self.idx = indextype
        self.samples = VCF(vcfpath).samples

    def load(self):
        # cyvcf2 object returned can be read only once
        return VCF(self.path)

    @property
    def variants(self) -> pd.Index:
        """
        Read variants identifiers ordered as in the input file
        :return:
        """
        vcfobj = self.load()
        vars = []
        if self.idx == 'id':
            for var in vcfobj:
                vars.append(var.ID)
        if self.idx == 'chrom:pos':
            for var in vcfobj:
                vars.append(':'.join([str(var.CHROM), str(var.POS)]))

        return pd.Index(data=vars, dtype=str, name='variants')

    @property
    def phases(self) -> pd.Series:
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars), len(self.samples)), dtype=float)
        for i, var in enumerate(vcfobj):
            arr[i, :] = var.gt_phases

        return pd.DataFrame(arr, index=vars, columns=self.samples, dtype=bool)

    def vcf2dframe(self) -> tuple:
        """
       Throws the genotypes values of a VCF file into side-DataFrames.
       :return: two data frames, one for each allele of the genotype
       """
        vcfobj = self.load()
        vars = self.variants
        arr = np.empty((len(vars), len(self.samples), 2), dtype=int)
        for i, var in enumerate(vcfobj):
            arr[i, :, :] = np.array(var.genotypes)[:, :-1]
        # alleles 1
        df0 = pd.DataFrame(arr[:, :, 0], index=vars.rename('id'), columns=self.samples)
        # alleles 2
        df1 = pd.DataFrame(arr[:, :, 1], index=vars.rename('id'), columns=self.samples)

        return df0, df1

    def trinary_encoding(self) -> pd.DataFrame:
        vcfobj = self.load()
        vars = self.variants
        arr = np.empty((len(vars), len(self.samples)), dtype=int)
        for i, var in enumerate(vcfobj):
            tri = np.array(var.genotypes)[:, :-1].sum(axis=-1)  # warning if missing alleles -1
            arr[i, :] = tri
        dftrinary = pd.DataFrame(arr, index=vars, columns=self.samples, dtype=int)

        return dftrinary

    @property
    def af_info(self) -> pd.Series:
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars),), dtype=float)
        for i, var in enumerate(vcfobj):
            arr[i] = var.INFO['AF']

        return pd.Series(arr, index=vars, name='af_info')

    @property
    def aaf(self) -> pd.Series:
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars),), dtype=float)
        for i, var in enumerate(vcfobj):
            arr[i] = var.aaf

        return pd.Series(arr, index=vars, name='aaf')

    def aaf_binned(self, b=np.array([0.00, 0.01, 0.05])) -> pd.Series:
        """
        Bin alternate allele frequencies values in chosen classes.
        :param b: bins to use. Default is 3 classes with focus on low AAF.
        :return: pandas Series with chosen index type and binned AAF values.
        """
        aaf = self.aaf
        binner = lambda x: np.digitize(x, bins=b)

        return aaf.apply(binner).rename('aaf_bin')

    @property
    def missing_rate(self) -> pd.Series:
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars),), dtype=float)
        for i, var in enumerate(vcfobj):
            arr[i] = 1.0 - var.call_rate

        return pd.Series(arr, index=vars, name='missing_rate')

    @property
    def het_rate(self) -> pd.Series:
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars),), dtype=float)
        for i, var in enumerate(vcfobj):
            try:
                arr[i] = var.num_het / var.num_called
            except ZeroDivisionError:
                arr[i] = 0.0

        return pd.Series(arr, index=vars, name='het_rate')

    @property
    def hom_alt_rate(self) -> pd.Series:
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars),), dtype=float)
        for i, var in enumerate(vcfobj):
            try:
                arr[i] = var.num_hom_alt / var.num_called
            except ZeroDivisionError:
                arr[i] = 0.0

        return pd.Series(arr, index=vars, name='hom_alt_rate')

    @property
    def hom_ref_rate(self) -> pd.Series:
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars),), dtype=float)
        for i, var in enumerate(vcfobj):
            try:
                arr[i] = var.num_hom_ref / var.num_called
            except ZeroDivisionError:
                arr[i] = 0.0

        return pd.Series(arr, index=vars, name='hom_ref_rate')

    @property
    def hom_rate(self) -> pd.Series:
        return self.hom_alt_rate.add(self.hom_ref_rate)

    @staticmethod
    def concatcols(seriescols: list):
        return pd.concat(seriescols, axis=1)

    @staticmethod
    def writetocsv(df: pd.DataFrame, title: str, idx: bool = True, hdr: bool = True) -> None:
        """
        Write input data frame to csv file in the current working directory
        :param df: pandas data frame to be written
        :param title: name for saving the csv file
        :param idx: bool: write row names (variants ID)
        :param hdr: bool: write columns names as header of the csv
        :return: -
        """
        df.to_csv(title,
                  sep='\t',
                  header=hdr,
                  index=idx,
                  encoding='utf-8')


class PandasMixedVCF(object):
    #TODO: implement aaf property
    """
    Pandas objects and methods for manipulating VCF files. Any format.
    Implements pysam methods into Pandas structures.
    Drawback: extremely slow...
    """
    def __init__(self, vcfpath: FilePath, format: str = None, indextype: str = 'id'):
        """
        :param vcfpath:
        :param indextype: identifier for variants: 'id', 'chrom:pos'.
        Must be 'chrom:pos' if the input has been generated by Phaser
        """
        self.path = vcfpath
        self.fmt = format
        self.idx = indextype
        obj = pysam.VariantFile(self.path)
        self.samples = list(obj.header.samples)

    def load(self):
        # object returned can be read only once
        return pysam.VariantFile(self.path)

    @property
    def variants(self) -> pd.Index:
        """
        Read variants identifiers ordered as in the input file
        :return:
        """
        vcfobj = self.load()
        vars = []
        if self.idx == 'id':
            for var in vcfobj:
                vars.append(var.id)
        if self.idx == 'chrom:pos':
            for var in vcfobj:
                vars.append(':'.join([str(var.chrom), str(var.pos)]))

        return pd.Index(data=vars, dtype=str, name='variants')

    @property
    def phases(self) -> pd.DataFrame:
        # TODO: if fmt GT
        vcfobj = self.load()
        vars = self.variants
        arr = np.zeros((len(vars), len(self.samples)), dtype=float)
        for i, var in enumerate(vcfobj):
            pass
            # arr[i, :] = var.gt_phases

        return pd.DataFrame(arr, index=vars, columns=self.samples, dtype=bool)

    def vcf2dframe(self) -> tuple:
        # TODO: deprecate
        """
       Throws the genotypes values of a VCF file into side-DataFrames.
       :return: two data frames, one for each allele of the genotype
       """
        vcfobj = self.load()
        vars = self.variants
        arr = np.empty((len(vars), len(self.samples), 2), dtype=int)
        for i, var in enumerate(vcfobj):
            arr[i, :, :] = np.array(g[self.fmt] for g in var.samples.values()).astype(float)
        # alleles 1
        df0 = pd.DataFrame(arr[:, :, 0], index=vars.rename('id'), columns=self.samples)
        # alleles 2
        df1 = pd.DataFrame(arr[:, :, 1], index=vars.rename('id'), columns=self.samples)

        return df0, df1

    def genotypes(self) -> pd.DataFrame:
        """
       Throws the formatted genotypes values of a VCF file into a DataFrame.
       :return: DataFrame
       """
        lines = chkvcf.PysamVariantCallGenerator(self.path, format=self.fmt)
        df = pd.DataFrame(lines, index=self.variants.rename('id'), columns=self.samples)

        return df

    def trinary_encoding(self) -> pd.DataFrame:
        # TODO: fmt GT only!
        vcfobj = self.load()
        vars = self.variants
        arr = np.empty((len(vars), len(self.samples)), dtype=float)
        missing = np.vectorize(lambda x: np.nan if x is None else x)
        for i, var in enumerate(vcfobj):
            # missing are read as None
            gts = np.array([g[self.fmt] for g in var.samples.values()]).astype(float)
            tri = missing(gts).sum(axis=-1)
            arr[i, :] = np.nan_to_num(tri, nan=-1)
        dftrinary = pd.DataFrame(arr, index=vars, columns=self.samples, dtype=int)

        return dftrinary


class PanelVCF(object):
    """
    Assemble together a dict ('<>' identifier of VCF files (if compatible indices...)
    Join column-wise
    """
    def __init__(self, **vcffiles):
        self.vcffiles = vcffiles

    def join(self, idt='id'):
        pdvcfs = []
        for fname, fpath in self.vcffiles.items():
            frame = PandasVCF(fpath, indextype=idt).aaf.rename('aaf_' + fname)
            pdvcfs.append(frame)
        return pd.concat(pdvcfs, axis=1)


if __name__ == '__main__':
    # create GL encoded file from raw GT
    vcfin = '/home/camille/1000Genomes/data/gt/stratified/IMP.chr20.snps.gt.chunk10000.vcf.gz'
    vcfout = '/home/camille/1000Genomes/data/gl/IMP.chr20.snps.gl.chunk10000.vcf'
    if False:
        alltls.file_likelihood_converter(vcfin, vcfout,
                                         func=alltls.bin_gl_converter)  # easier for cross entropies not to log gl

    os.chdir('/home/camille/1000Genomes/data/gl/gl_adaptive/all_snps_all_samples')
    fpath = 'IMP.chr20.pooled.beagle2.gl.chunk10000.vcf.gz'
    mydf = PandasMixedVCF(fpath)
    print(mydf)

    os.chdir('/home/camille/1000Genomes/data/gl/gl_adaptive/all_snps_all_samples')
    gtglpth = 'IMP.chr20.pooled.beagle2.gl.chunk10000.corr.vcf.gz'
    gtpth = '/home/camille/1000Genomes/data/gt/ALL.chr20.snps.gt.chunk10000.vcf.gz'

    pysamobj = PandasMixedVCF(gtglpth, format='GP')

    cyvcfobj = PandasVCF(gtpth)
